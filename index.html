<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Gp Bootstrap Template - Index</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="assets/vendor/remixicon/remixicon.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <!-- =======================================================
  * Template Name: Gp
  * Updated: Mar 10 2023 with Bootstrap v5.2.3
  * Template URL: https://bootstrapmade.com/gp-free-multipurpose-html-bootstrap-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <!-- ======= Header ======= -->
  <header id="header" class="fixed-top ">
    <div class="container d-flex align-items-center justify-content-lg-between">

      <h1 class="logo me-auto me-lg-0"><img src="assets/img/om_logo.png" class="img-fluid" alt=""></h1>
      
      <!-- Uncomment below if you prefer to use an image logo -->
      <!-- <a href="index.html" class="logo me-auto me-lg-0"><img src="assets/img/logo.png" alt="" class="img-fluid"></a>-->

      <nav id="navbar" class="navbar order-last order-lg-0">
        <ul>
          <li><a class="nav-link scrollto active" href="#hero">Introduction</a></li>
          <li><a class="nav-link scrollto" href="#architecture">Architecture</a></li>
          <li><a class="nav-link scrollto" href="#workflow">Workflow</a></li>
          <li><a class="nav-link scrollto " href="#recommendation">Recommendation</a></li>
          <li><a class="nav-link scrollto" href="#evaluation">Evaluation</a></li>
          <li><a class="nav-link scrollto" href="#challenges">Challenges</a></li>
          <li><a class="nav-link scrollto" href="#forward">Way Forward</a></li>
          <!-- <li class="dropdown"><a href="#"><span>Drop Down</span> <i class="bi bi-chevron-down"></i></a>
            <ul>
              <li><a href="#">Drop Down 1</a></li>
              <li class="dropdown"><a href="#"><span>Deep Drop Down</span> <i class="bi bi-chevron-right"></i></a>
                <ul>
                  <li><a href="#">Deep Drop Down 1</a></li>
                  <li><a href="#">Deep Drop Down 2</a></li>
                  <li><a href="#">Deep Drop Down 3</a></li>
                  <li><a href="#">Deep Drop Down 4</a></li>
                  <li><a href="#">Deep Drop Down 5</a></li>
                </ul>
              </li>
              <li><a href="#">Drop Down 2</a></li>
              <li><a href="#">Drop Down 3</a></li>
              <li><a href="#">Drop Down 4</a></li>
            </ul>
          </li> -->
          <!-- <li><a class="nav-link scrollto" href="#contact">Contact</a></li> -->
        </ul>
        <i class="bi bi-list mobile-nav-toggle"></i>
      </nav><!-- .navbar -->

      <!-- <a href="#about" class="get-started-btn scrollto">Get Started</a> -->

    </div>
  </header><!-- End Header -->

  <!-- ======= Hero Section ======= -->
  <section id="hero" class="about">
    <div class="container" >

      <div class="body_text" >
        <h3>Motivation</h3>
        <p> “Sharing relevant memes is an Art, and getting quality content is a Bliss” </p>
        <p> There are existing platforms like Instagram, Facebook (especially groups), Twitter, and Reddit which provide users with memes as well as other content. But there are disadvantages of these platforms for consuming memes. Most people turn to these platforms just to get view some quality meme content to get a break from work.</p>
        <ul>
          <li>Get distracting Advertisements that somewhat spoil the meme experience</li>
          <li>Often we run into irrelevant posts or memes as these platforms recommend based on interactions with all types of content and not just based on liked memes</li>
          <li>Twitter is not a safe place unlike CSCE 670 Slack random channel and we often run into heated debates and comments rather than memes</li>
        </ul>

        <p> Thus we have developed a meme recommendation application that will solve the above stated problems and give users</p>
        <ul>
          
          <li> Relevant Memes</li>
          <li> Popular Memes</li>
          <li> And Only Memes</li>
        </ul>
        
   

    </div>
  </section>
 

  <main id="main">

    <!-- ======= Architecture Section ======= -->
    <section id="architecture" class="about">
      <div class="container" >

        <div class="row">
          <div class="col-lg-6 order-1 order-lg-2" >
            <img src="assets/img/architecture.png" class="img-fluid" alt="">
          </div>
          <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" data-aos="fade-right" data-aos-delay="100">
            <h3>Project Architecture</h3>
            <p class="fst-italic">
              we have used Django framework to build the OnlyMemes website. The important components interacting with app include dynamodb, sqlitedb and Redis cache.
              Our Recommendation algorithm is integrated with Django app and runs as a server side function.
            </p>
            <ul>
              <li><i class="ri-check-double-line">Django</i> The Django app is the platform through which users would view the memes. It is responsible for user registration and authenication. It also renders the users feed and communicates with the dynamo db to update and retrieve the user data</li>
              when the feed of the user is rendered, there is an AJAX callback from the client to the server which triggers the recommnedation algorithm to produce the next feed for the user.
              <li><i class="ri-check-double-line">SQLitedb</i> Sqlitedb is used for user registraion and authenication. This database would be accessed only at the login and registration pages</li>
              <li><i class="ri-check-double-line">Dynamodb</i> Dynamo db contains the data and tables necessary for running the webapp and the recommendation algorithm
              <p>we have three important tables for our application.</p>
              <p>1) memes_metadata</p>
                <p>The memes metadata table contains the information related to the data extracted from instagram. This table would be used by the recommendation algorithm for computing similarity scores and final rank
              <p>2) meme_embeddings</p>
                <p>Our recommendation alogrithm runs based on the similarity of the hashtags. The hastags of the memes are fixed</p>
                <p>So, we are precomputing the bert and doc embedding and storing in the dynamo db. The recommendation algorithm would pull these embeddings from the dynamo db for ranking the memes.</p>
              <p>3) users</p>
                <p>The users table is used both by the webapp and the recommendation algorithm</p>
              <img src="assets/img/dynamo.png" alt="A beautiful landscape">
              <li><i class="ri-check-double-line">Redis</i>Redis is used for cache to store the word2vec embeddings of the hashtags present in the memes_metadata. This component is needed as the word2vec model (goole-news-300) is a 1.5GB bin file and takes more than 90s to load the model. By using redis,the total runtime of the recommendation algorithm got reduced to 18s thus improving the efficiency by 5X.
              </li>
            </ul>
          </div>
        </div>

      </div>
    </section>
    <!-- End About Section -->


        <!-- ======= Workflow Section ======= -->
        <section id="workflow" class="about">
          <div class="container" >
    
            <div class="row">
              <div class="col-lg-6 order-1 order-lg-2" >
                <img src="assets/img/workflow.png" class="img-fluid" alt="">
              </div>
              <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" data-aos="fade-right" data-aos-delay="100">
                <h3>Django Workflow</h3>
                <p class="fst-italic">
                  We have developed a web application for our recommender system using the Django Framework with Python, and DynamoDB for the database. 
                  The landing page of our web application prompts users to log in and offers a sign-up function for new users.
                </p>
                <ul>
                  <li><i class="ri-check-double-line"></i> Data from user sign-up is kept in SQLitedb for authentication activities </li>
                  <li><i class="ri-check-double-line"></i> To address the cold start problem, we provide users with a selection of curated meme tags upon sign-up. </li>
                  <li><i class="ri-check-double-line"></i> Our recommendation algorithm runs in the backend and curates the content on the homepage based on the selected tags. This approach helps users receive personalized recommendations, even if they have no previous search history.</li>
                  <li><i class="ri-check-double-line"></i> User embeddings are updated based on the implicit user input such as likes and clicks. Using the updated embeddings our web application pulls new feed data from DynamoDB.</li>
                </ul>
                <p>
                  The web application is designed and developed in line with user's preferences which is updated periodically using user interactions. It is designed to incorporate minimum user intervention while ensuring maximum user satisfaction.
                </p>
              </div>
            </div>
    
          </div>
        </section>
        <!-- End About Section -->



            <!-- ======= Recommendation Section ======= -->
    <section id="recommendation" class="about">
      <div class="container" >

        <div class="row">
          <div class="col-lg-6 order-1 order-lg-2" >
            <img src="assets/img/BERT.jpg" class="img-fluid" alt="">
          </div>
          <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" data-aos="fade-right" data-aos-delay="100">
            <h3>Recommendation Engine</h3>
            <p >
              <h5>Generating Meme/User Embedding</h5>
              <p> To recommend memes to users based on their interest and interaction with the feed, we use a content-based recommendation system. We tried extracting the meme text from using OCR but with our dataset consisting of a mix of images and videos, the quality of extracted meme text data was not sufficient to train our recommendation model. Thus we used the hashtags of the memes for generation embeddings for all the memes. To generate embeddings we used two methods as given below:</p>
              <ul>
                <li><i class="ri-check-double-line"></i> <b>Word2vec: </b> Word2vec is a popular natural language processing technique used for generating word embeddings, which are numerical representations of words in a high-dimensional space. The goal of word2vec is to capture the semantic meaning of words by training a neural network on a large corpus of text. In this project, we used Google News 300 Word2vec pre-trained model to create a word2vec higher dimensional representation. By using word2vec to generate embeddings for hashtags associated with memes, we can capture the semantic meaning of the hashtags and use them to create more accurate and effective representations of the memes.</li>
                <li><i class="ri-check-double-line"></i> <b>BERT</b> Bidirectional Encoder Representations from Transformers is a deep learning model that uses a combination of unsupervised and supervised learning to generate contextualized word embeddings. It uses a transformer architecture, which is a type of neural network that can process entire sequences of data at once, to encode the context of each word in a sentence. We used pre-trained BERT on meme tags and user queries to generate BERT-based dense embeddings. BERT is capable of capturing the relationships between words in a given sentence, which can be useful for generating embeddings that represent the overall meaning of a meme based on its associated hashtags and also can handle out-of-vocabulary words, which can be common in memes that often use non-standard or invented words or phrases.</li>
              </ul>
            </p>
            <p>
              <h5>Soft Cosine Similarity</h5>
              Soft cosine similarity is a measure of similarity between two text documents or vectors that take into account the semantic similarity between their constituent words or features. Unlike traditional cosine similarity, which only measures the cosine of the angle between two vectors in a high-dimensional space, soft cosine similarity also considers the relationships between the words or features in the two vectors. Given below are the advantages of using soft cosine similarity:
              <ul>
                <li><i class="ri-check-double-line"></i>Takes into account the semantic similarity between the dimensions of the vectors</li>
                <li><i class="ri-check-double-line"></i>Can compare vectors of different types</li>
              </ul>
            </p>
            

            <p >
              <h5>Generating User Queries</h5>
              To tackle the cold start problem we give users a set of tags or interests to choose from. From these tags, the user selects his/her favorite tags, and based on those we generate the initial embeddings for the user. We then show the user the feed based on the initial user embedding. When the user interacts with the memes by liking or sharing we change the user query by adding the tags of these memes to the original chosen tags. Based on the updated user query we generate new embeddings for the user and get an updated feed of memes ranked based on the criteria given below.
            </p>


            <p >
              <h5>Generating Feed and Ranking Memes</h5>
              We generate the updated feed based on the user interaction dynamically. We have a list of memes that the user has already seen and also a list of liked memes. Based on the current user embedding we calculate the similarity with all memes embeddings. Finally, we calculate the score for each meme based on two factors:
              <ul>
                <li><i class="ri-check-double-line"></i> Similarity </li>
                <li><i class="ri-check-double-line"></i> Popularity (Number of Likes and comments)</li>                
              </ul>
              Finally, we inject some random popular memes (unseen by the user) into the top-ranked memes and display a shuffled feed of top memes to the user. This avoids the feed to be restricted to a few categories that the user keeps on liking and allows users to explore different areas.
 
            </p>
          </div>
        </div>

      </div>
    </section>
    <!-- End About Section -->



        <!-- ======= Evaluation Section ======= -->
        <section id="evaluation" class="about">
          <div class="container" >
    
            <div class="row">
              <div class="col-lg-6 order-1 order-lg-2" >
                <!-- <img src="assets/img/architecture.png" class="img-fluid" alt=""> -->
                <table>
                  <thead>
                    <tr>
                      <th></th>
                      <th>Our method</th>
                      <th>Baseline</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Average precision@20</td>
                      <td>0.85</td>
                      <td>0.72</td>
                    </tr>
                    <tr>
                      <td>Average NDCG</td>
                      <td>0.74</td>
                      <td>0.68</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" >
                <h3>Evaluation</h3>
                <p>
                  Evaluation is a crucial part of the recommendation system and is required for testing the performance of methods used for recommendation. In our case, we use a content-based recommendation system for memes and rank the memes based on the similarity between embeddings. While there are other factors like popularity and diversification of feed using random popular memes, we only evaluate the similarity part of our system with the baseline method as the other parts are independent of the system used and are just to improve upon the recommendations of our main system. 
                </p>
                <p>We compare our method of using Word2vec (trained on Google News 300) and BERT with soft cosine similarity with a baseline method we implemented in class using Wor2Vec embeddings with cosine similarity. We manually define images that are relevant for each tag and then compare these methods on two metrics Precision@20 and NDCG by using these methods to get the top 20 memes for these hashtags.</p>
                <ul>
                  <li><i class="ri-check-double-line"></i> <b>Precision@20 - </b> It measures the proportion of recommended items that are relevant to the user, out of the top 20 recommended items.
                  <br>
                  <p>precision@20 = (# of relevant items in top 20 recommended items) / 20</p> </li>
                    
                  <li><i class="ri-check-double-line"></i> <b>NDCG </b> NDCG (Normalized Discounted Cumulative Gain) measures the relevance and position of each recommended item and assigns a score to the list of recommended items based on these factors.  <p>NDCG = DCG / IDCG</p></li>
                  
                </ul>

              </div>
            </div>
    
          </div>
        </section>
        <!-- End About Section -->



            <!-- ======= Challenges Section ======= -->
    <section id="challenges" class="about">
      <div class="container" >

        <div class="row">
          <!-- <div class="col-lg-6 order-1 order-lg-2" data-aos="fade-left" data-aos-delay="100">
            <img src="assets/img/architecture.png" class="img-fluid" alt="">
          </div> -->
          <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" >
            <h3>Challenges</h3>

            <p class="fst-italic">
              As we built OnlyMemes there were a few challenges that we tackled during this project.
            </p>
            <ul>
              <li><i class="ri-check-double-line"></i> <b>Data Gathering</b> - We build a script to scrape memes from Instagram as a dataset for this project but due to API rate limitation this was a major roadblock in the data gathering process. To tackle this we used some tweaks to gather data by designing a continuous scraping process with rate limitation</li>
              <li><i class="ri-check-double-line"></i> <b> Meme content extraction </b> - As the data extracted was a mix of videos and images and the content of images was also not uniform it was a challenge to extract meme text using OCR. We tried all models like Tesseract, EasyOCR, and KerasOCR but the quality of the meme text data extracted was not good or missing for most of the posts. Thus we decide to run our models only on meme tags. </li>
              <li><i class="ri-check-double-line"></i> <b> Cold Start </b> - To eliminate the cold start problem we implemented the Spotify/Netflix approach to let users choose a set of favorite tags initially. Also as new memes are added daily this is not a concern in our system as we can create image embedding using tags </li>
              <li><i class="ri-check-double-line"></i> <b>Design Decisions</b> - There were many design decisions for the application like when to update the feed, how to update the feed. We used the principles taught in class like minimizing user traction for using the app and diversification of feed to take these design decisions</li>
            </ul>

          </div>
        </div>

      </div>
    </section>
    <!-- End About Section -->



        <!-- ======= Way Forward Section ======= -->
        <section id="forward" class="about">
          <div class="container" >
    
            <div class="row">
              <!-- <div class="col-lg-6 order-1 order-lg-2" data-aos="fade-left" data-aos-delay="100">
                <img src="assets/img/workflow.png" class="img-fluid" alt="">
              </div> -->
              <div class="col-lg-6 pt-4 pt-lg-0 order-2 order-lg-1 content" >
                <h3>Way Forward</h3>
                <p class="fst-italic">
                  As the timeline of this project was limited, we can think of a few improvements that we can add to our application.
                </p>
                <ul>
                  <li><i class="ri-check-double-line"></i> <b>More Data</b> We look forward to using a larger dataset with more quality memes to improve our recommendations</li>
                  <li><i class="ri-check-double-line"></i> <b>Meme Text Extraction</b> With large and good-quality data we can implement OCR for meme text extraction and use meme text and tags to build meme embeddings</li>
                  <li><i class="ri-check-double-line"></i> <b>Meme Tag Generation</b> Sometimes memes are not tagged or captioned properly thus we can extract meme text, and meme content to generate meme tags to include such memes in our system. This would be possible using deep learning models to be trained on meme content to predict the tags.</li>
                </ul>

              </div>
            </div>
    
          </div>
        </section>
        <!-- End About Section -->







  <div id="preloader"></div>
  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
  <script src="assets/vendor/aos/aos.js"></script>
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
  <script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="assets/vendor/php-email-form/validate.js"></script>

  <!-- Template Main JS File -->
  <script src="assets/js/main.js"></script>

</body>

</html>